# 分布式事务设计

## 数据一致性

任何人，任何时间，任何地点，任何接入方式，任何服务都要保证数据是一致的。

## 为什么会出现数据不一致

微服务的拆分产生了多库多表，也就意味着存在多个DB和缓存。因为网络等其他原因造成数据不一致问题。

## 如何解决数据不一致问题

一般情况下请求流程如下：

* 本地事务操作本地数据库，操作之后将消息发送到MQ
* MQ收到消息做进一步处理，推送给订阅者或者返回ack给消息发送者

但是上述流程很可能因为网络的原因造成消息发送失败，导致数据的不一致性，所以要采用分布式事务来解决这种问题。

## 分布式事务分类

### 刚性分布式事务

刚性分布式事务满足传统分布式事务特性ACID\(原子性，一致性，隔离性，持久性\)。

XA模型实在X/open CAE specification模型中定义，XA规范由AP，RM，TM组成。其中AP操作事务，RM负责管理数据库，TM即数据库本身提供事务支持。

两阶段提交2PC是XA规范的标准实现，TM发起prepare投票，RM都统一后再commit，commit过程中出现宕机则执行XA recover再次进行commit补偿。

最终达到的是CP模型。

#### 缺点

* 同步阻塞模型
* 数据库资源锁定时间过长
* 全局锁，并发低
* 不适合长事务场景（分布式事务）

### 柔性分布式事务

柔性分布式事务实现的是最终一致性，AP模型。

BASE理论：

* 基本可用
* 柔性状态
* 最终一致性

柔性一致性是对XA协议的妥协，它通过降低一致性要求，降低数据库资源锁定时间，提升可用性。

#### 典型实现

#### TCC模型

Try-Confirm-Cancel，每个自业务都要实现TCC接口，对业务入侵大。

* try:尝试执行业务，完成所有业务检查，预留必要的业务资源
* confirm：做真正的执行业务，不再做业务检查
* cancel：释放try阶段预留的业务资源



#### Saga模型

Saga模型把分布式事务拆分成多个本地事务，每个事务都有相应的执行模块和补偿模块。当saga任意本地事务出错调用对应的补偿方法，达到事务最终的一致性。

saga恢复方式：

* 向后补偿：补偿所有已经完成的事务，如果任意子事务失败
* 向前补偿：尝试失败的事务，假设每个子事务最终都会成功

## 分布式事务对比

![](../.gitbook/assets/image%20%28162%29.png)

## **如何实现**

### 异步场景

异步场景下是基于MQ实现。分为以下两种实现方案。

#### 方案一

业务方提供操作成功回查功能。

* MQ要提供类似XA的分布式事务功能

![](../.gitbook/assets/image%20%28160%29.png)

* 半消息：暂时不能投递的消息，发送方已经成功将消息发送到了MQ服务端，但是MQ未收到发送方的二次确认，此时该消息被标记为暂时不能投递。
* 消息回查：由于网络或重启等其他原因，导致发送方的二次确认消息丢失，MQ通过扫描发现有半消息长时间未被确认，此时主动向发送方查询此条消息的状态。

方案优缺点：

优点：通用

缺点：

* 业务方需要提供回查接口，对业务侵入大
* 发送消息非密等，服务端需要做密等处理
* MQ需要提供轮询功能：类似于RocketMQ

#### 方案二

采用本地消息事务表

![](../.gitbook/assets/image%20%28163%29.png)

存在的问题

发送方消息不密等，至少会将消息发送到MQ一次。在消费方通过分布式锁做密等处理。如果失败则做错误日志记录，然后人工介入。

### 同步场景



