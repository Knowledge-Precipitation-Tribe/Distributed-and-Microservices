# 分布式锁设计

## 什么是分布式锁

在分布式的环境下，锁定全局的唯一资源使得请求变为串行化。实际应用表现为互斥锁。

## CAP

![](../.gitbook/assets/image%20%28160%29.png)

CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。

## 分布式锁的目的

* 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。
* 正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。

## 分布式锁的设计目标

为了保证服务的高可用性，对于分布式锁的设计要包含以下几个目标

* 强一致性
* 锁自动续约以及锁自动释放
* 代码高度抽象，业务接入简单
* 可视化管理后台，用于监控以及管理

## 分布式锁设计方案

![](../.gitbook/assets/image%20%28147%29.png)

对于ETCD来说有以下几个场景

### 申请锁，成功拿到

根据key申请锁，并设置ttl时间，etcd收到申请之后生成全局的唯一uuid，用它来标识这把锁。

![](../.gitbook/assets/image%20%28146%29.png)

### 申请锁，但锁已被持有

申请锁失败后会返回申请锁失败。

### 续约锁

在成功申请锁后，会启动心跳线程，每次ttl/3的时间会向etcd更新持有锁的时间。

![](../.gitbook/assets/image%20%28145%29.png)

### 释放锁

业务操作完成之后，主动调用接口释放锁。

```text
curl http://127.0.0.1:2379/v2/keys/foo?prevValue=prev_uuid -XDELETE
```

如果服务异常中断，等待原有锁的ttl时间，过期就自动释放掉了。

## 分布式锁特殊场景

从获得锁到释放锁中间的数据密等等逻辑需要根据业务实践，例如线程A操作订单，先拿到锁，操作之后修改订单状态，然后释放锁。线程B再来操作订单时，可以拿到锁，但是订单状态已经改变了就不进行操作，此时释放锁，通过这样的方式实现数据密等问题。

