# TCP长连接与短连接

## 什么是TCP连接

当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要**三次握手**的，而释放则需要**四次握手**，所以说每个连接的建立都是需要消耗时间和资源的。

### 三次握手



### 四次握手



## 什么是TCP短连接

client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作。

短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

## 什么是TCP长连接

client向server发起连接，server接受client连接，双方建立连接。client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

这里就涉及到如何保持连接活性的问题。

保活功能主要为服务端使用，服务端想要知道客户端是否仍在存在。如果客户端已经消失，这就使得服务器上残留了一个半开放的连接，而服务端又在等待来自客户端的数据，导致资源浪费，保活功能就是试图在服务端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何的动作，则服务端就向客户发一个探测报文段，客户端必须处于以下4个状态之一：

1. 客户端依然正常运行，并从服务器可达。客户的TCP响应正常，而服务端也知道对方是正常的，服务端在两小时后将保活定时器复位，重新探测。
2. 客户端已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务端总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
3. 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
4. 客户机正常运行，但是服务端不可达，这种情况与2类似。

从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不能再发挥作用了。

在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，使得服务端功能可用。

## 如何维持TCP长连接

当tcp连接被破坏后， 如果是死连接了， 服务端和客户端怎样才能知道信息能不能到达对方呢？ 很自然的想法是， 不断地给对方发探测信号， 看有没有回应， 这就是心跳机制的直白原理。

### 心跳

所谓的心跳即是数据包， 发心跳就是一方向另一方发送的数据包， 不断地发送， 如果收不到回应， 那么就有理由认为是tcp连接出了问题。 那为什么要叫心跳呢？ 你摸一下你的心， 你看它是不是均匀在跳？ 理解了吧， 均匀发出去的数据包就类似于均匀的心跳信号。 

发送的数据包像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。

### 如何实现心跳

如何及时有效地检测到一方的非正常断开，一直有两种技术可以运用。

* 一种是由TCP协议层实现的Keepalive
* 另一种是由应用层自己实现的心跳包。

在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO\_KEEPALIVE。系统默认是设置的2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。 

心跳包一般来说都是在逻辑层发送空的echo包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。 

其实，要判定掉线，只需要send或者recv一下，如果结果为零，则为掉线。但是，在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。 

在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的数据清理呀，重新连接呀……当然，这个自然是要由逻辑层根据需求去做了。 

总的来说，心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。

### **心跳检测步骤**

1. 客户端每隔一个时间间隔发生一个探测包给服务器 
2. 客户端发包时启动一个超时定时器 
3. 服务器端接收到检测包，应该回应一个包 
4. 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器 
5. 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了

### KeepAlive方式

有三种使用 KeepAlive 的实践方案：

1. 默认情况下使用 KeepAlive 周期为 2 个小时，如不选择更改，属于误用范畴，造成资源浪费：内核会为每一个连接都打开一个保活计时器，N 个连接会打开 N 个保活计时器。 优势很明显：
   * TCP 协议层面保活探测机制，系统内核完全替上层应用自动给做好了
   * 内核层面计时器相比上层应用，更为高效
   * 上层应用只需要处理数据收发、连接异常通知即可
   * 数据包将更为紧凑
2. 关闭 TCP 的 KeepAlive，完全使用应用层心跳保活机制。由应用掌管心跳，更灵活可控，比如可以在应用级别设置心跳周期，适配私有协议。
3. 业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果。

各个框架的设计都有所不同，例如 Dubbo 使用的是方案三，但阿里内部的 HSF 框架则没有设置 TCP 的 KeepAlive，仅仅由应用心跳保活。和心跳策略一样，这和框架整体的设计相关。

> 本小节参考自：[https://www.cnkirito.moe/tcp-talk/](https://www.cnkirito.moe/tcp-talk/)

## HTTP中的KeepAlive与TCP中KeepAlive

* HTTP 协议的 KeepAlive 意图在于连接复用，同一个连接上串行方式传递请求 - 响应数据
* TCP 的 KeepAlive 机制意图在于保活、心跳，检测连接错误。

## 推荐资料

{% embed url="https://tldp.org/HOWTO/html\_single/TCP-Keepalive-HOWTO/" %}



